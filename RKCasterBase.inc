Sub Init_RKCasterBase
	/varset EarlyEscapePauseDuration 1
	/declare LowManaLevel int outer 10
	/declare SpellMemSlot int outer 9
	
	/call AddToArray "CombatActionSubs" "ExecuteCasterCombatActions"
	/call AddToArray "PreTargetAcquisitionSubs" "ExecuteCombatBuffs"
	/call AddToArray "NonCombatSubs" "ExecuteNonCombatBuffs"
	/call AddToArray "BurnCombatActionSubs" "ExecuteCasterBurn"	
	
	/call GetNoCooldownSpellGem
	/declare NoCooldownSpellGem int outer ${Macro.Return}
		
	/declare OffGCDCombatActionSubs[${DynamicArraySize}] string outer

	/declare DetrimentalSpellDebuffNames[${DynamicArraySize}] string outer
	/declare DetrimentalSpells[${DynamicArraySize}] string outer	

 	/declare GiftSpells[${DynamicArraySize}] string outer

	/declare CombatSelfBuffs[${DynamicArraySize}] string outer
	/declare CombatSelfBuffsNames[${DynamicArraySize}] string outer	

	/declare ShouldCheckTankBuffs bool outer TRUE	

	/declare CombatPartyBuffs[${DynamicArraySize}] string outer
	/declare CombatPartyBuffsNames[${DynamicArraySize}] string outer	

	/declare CombatTankBuffs[${DynamicArraySize}] string outer
	/declare CombatTankBuffsNames[${DynamicArraySize}] string outer	
	
	/declare NonCombatSelfBuffs[${DynamicArraySize}] string outer
	/declare NonCombatSelfBuffsNames[${DynamicArraySize}] string outer	
	
	/declare NonCombatPartyBuffs[${DynamicArraySize}] string outer
	/declare NonCombatPartyBuffsNames[${DynamicArraySize}] string outer	

	/declare GiftProcName string outer Gift of Ascendant Exquisite Radiant Mana

	/echo Done initializing caster base!
/return

Sub ExecuteCasterCombatActions
	/if (${DebugMode}) /echo ExecuteCasterCombatActions
	/if (!${Me.SpellReady[${NoCooldownSpellGem}]}) {
		/call ExecuteArrayOfSubs "OffGCDCombatActionSubs"
	}
	
	/if (${Target.Type.Equal[NPC]})	{
		|/echo caster banestrike
		/call RKAACast "Banestrike" ${Target.ID}
	}
	
	/if (${Stick.Active} && ${Spawn[id ${CurrentStickTargetId}].Distance} > 25) /return FALSE
	
	/if (${Me.Moving} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/call ExecuteGiftProc
	/call ExecuteDebuffs
	
	/if (!${Me.AltAbility[Glyph of Destruction II]} && ${Me.AAPoints} > 10 && ${GlyphMode}) {
		/alt buy 7019
		/alt buy 5000
		/echo buying caster glyph of destruction II
	}

	/if (!${Me.AltAbility[Glyph of Courage]} && ${Me.AAPoints} > 10 && ${GlyphMode}) {
		/alt buy 7019
		/alt buy 5000
		/echo buying caster Glyph of Courage
	}
	
	
	
	/call ExecuteBuffsWithUniqueNames "CombatSelfBuffs"
/return FALSE

Sub ExecuteCasterBurn
	/if (${Me.AAPoints} > 50 && ${GlyphMode}) {
		/if (!${Me.AltAbility[Glyph of Destruction II]}) {
			/alt buy 7019
			/alt buy 5000
			/echo buying caster glyph of destruction II
		}
		/call RKAACast "Glyph of Destruction II" ${CurrentTargetId}
		/if (${Macro.Return}) /docommand /${ChatCommand} "Running Glyph of Destruction II"
	}
/return FALSE

Sub GetNoCooldownSpellGem
	/declare gemIndex int local 10
	/for gemIndex 1 to 12
		/if (${Me.Gem[${gemIndex}].RecastTime} > 1.5) /next gemIndex
		/return ${gemIndex}
	/next gemIndex
/return 1

Sub AddDetrimentalSpellWithUniqueDebuffName(string spellName, string effectName)
	/call AddToArray "DetrimentalSpells" "${spellName}"
	/varset DetrimentalSpellDebuffNames[${Macro.Return}] ${effectName}
/return FALSE

Sub AddToArrayWithUniqueName(string arrayName, string spellName, string effectName)
	/call AddToArray "${arrayName}" "${spellName}"
	/declare arrayNameWithSuffex string local "${arrayName}Names"

	/echo Adding ${effectName} to ${arrayNameWithSuffex} at position ${Macro.Return}
	/varset ${arrayNameWithSuffex}[${Macro.Return}] ${effectName}
/return FALSE

Sub ExecuteGiftProc
	/if (${DebugMode}) /echo ExecuteGiftProc
	/declare i int local
	/if (${Me.Song[${GiftProcName}].ID}) {
		/for i 1 to ${GiftSpells.Size}
			/if (!${Cast.Ready[${GiftSpells[${i}]}]}) /next i
			/call RKCast "${GiftSpells[${i}]}" ${CurrentTargetId}
			/if (${Macro.Return}) /return TRUE
		/next i
	}
/return FALSE

Sub ExecuteNukes(string nukeArray)
	/if (${DebugMode}) /echo ExecuteNukes for array ${nukeArray}
	/declare i int local
	/for i 1 to ${${nukeArray}.Size}
		/if (!${Bool[${${nukeArray}[${i}]}]}) /next i
		/if (!${Cast.Ready[${${nukeArray}[${i}]}]}) /next i

		/call RKCast "${${nukeArray}[${i}]}" ${CurrentTargetId}
		/if (${Macro.Return}) /return TRUE
	/next i
/return FALSE

Sub ExecuteDebuffs
	/if (${DebugMode}) /echo ExecuteDebuffs for array ${debuffArray}
	/declare i int local
	/declare spellName string local
	/declare debuffName string local	
	/if (!${Target.ID}) /return FALSE

	/if (${Target.Type.Equal[PC]}) /return FALSE
	
	/for i 1 to ${DetrimentalSpells.Size}
		/if (${DetrimentalSpells[${i}].Length} == 0) /return FALSE
		/varset spellName ${DetrimentalSpells[${i}]}
	
		/if (!${Bool[${spellName}]} || ${spellName.Length} < 2) /next i
		/if (${DebugMode}) /echo debuff spellName - ${spellName}

		/if (${Bool[${DetrimentalSpellDebuffNames[${i}]}]}) {
			/varset debuffName ${DetrimentalSpellDebuffNames[${i}]}
		} else {
			/varset debuffName ${spellName}
		}

		/if (!${Bool[${debuffName}]}) /varset debuffName - ${spellName}
		/if (${DebugMode}) /echo debuffName - ${debuffName}
		/if (${DebugMode}) /echo trying to cast ${spellName}
		/call IsSpellMemorized "${spellName}"
		/if (${Macro.Return}) {
			/if (${DebugMode}) /echo ${spellName} is memmed
			/if (${Me.GemTimer[${Me.Gem[${spellName}]}]} > 5) /next i
			/call RKDebuffCast "${spellName}" "${debuffName}" ${CurrentTargetId}
		 	/if (${Macro.Return}) /return TRUE
		} else {
			/if (${Bool[${AltAbility[${spellName}]}]}) {
				/if (!${Me.AbilityReady[${spellName}]}) /next i
				/if (${DebugMode}) /echo casting AA ${spellName}
				/call RKAACast "${spellName}"
				/if (${Macro.Return}) /return TRUE
			}
		}
	/next i
/return FALSE

Sub ExecuteCombatBuffs
	/if (${DebugMode}) /echo ExecuteCombatBuffs
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/if (${Me.Moving} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/call ExecuteSelfBuffs "CombatSelfBuffs"
	/if (${Macro.Return}) {
		/if (${DebugMode}) /echo Exiting early because of self buffs
		/return TRUE
	}
	
	/call ExecuteGroupBuffs "CombatPartyBuffs"
	/if (${Macro.Return}) {
		/if (${DebugMode}) /echo Exiting early because of party buffs
		/return TRUE
	}
	
	/if (${ShouldCheckTankBuffs}) {
		/call ExecuteTankBuffs "CombatTankBuffs"
		/if (${Macro.Return}) {
			/if (${DebugMode}) /echo Exiting early because of tank buffs
			/return TRUE
		}
	}
	
/return FALSE

Sub ExecuteNonCombatBuffs
	/if (${DebugMode}) /echo ExecuteNonCombatBuffs
	/if (${Me.Moving} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/call ExecuteBuffsWithUniqueNames "NonCombatSelfBuffs"
	|/if (${Macro.Return}) /return TRUE
	/call ExecuteGroupBuffs "NonCombatPartyBuffs"
	|/if (${Macro.Return}) /return TRUE
/return FALSE

Sub ExecuteBuffsWithUniqueNames(string arrayName)
	/if (${DebugMode}) /echo ExecuteNonCombatSelfBuffsWithUniqueNames
	/if (${Me.Moving} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/declare i int local
	/declare spellName string local
	/declare buffName string local	

	/for i 1 to ${${arrayName}.Size}
		/varset spellName ${${arrayName}[${i}]}
		/if (!${Bool[${spellName}]}) /next i
		/varset buffName ${${arrayName}Names[${i}]}
		/if (!${Bool[${buffName}]}) /varset buffName ${spellName}

		/if (${Bool[${AltAbility[${spellName}]}]}) {
			/if (${DebugMode}) /echo trying to cast AA ${spellName}
			/call RKAACast "${spellName}" ${Me.ID}
		} else {
			/if (${DebugMode}) /echo trying to cast ${spellName} for buff: ${buffName}
			/call RKBuffWithUniqueName "${spellName}" "${buffName}" ${Me.ID}
			/return ${Macro.Return}
		}
	/next i
/return FALSE


Sub ExecuteSelfBuffs(string buffArray)
	/if (${DebugMode}) /echo ExecuteSelfBuffs from array ${buffArray}
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/declare i int local
	
	/for i 1 to ${${buffArray}.Size}
		/if (!${Me.GemTimer[${${buffArray}[${i}]}]} == 0) /next i
		/if (!${Bool[${${buffArray}[${i}]}]}) /return FALSE
		/if (${Bool[${${buffArray}Names[${i}]}]}) {
			/call RKBuffWithUniqueName "${${buffArray}[${i}]}" "${${buffArray}Names[${i}]}" ${Me.ID}
		} else {
			/call RKBuff "${${buffArray}[${i}]}" ${Me.ID}
		}
		/if (${Macro.Return}) /return TRUE
	/next i
/return FALSE

Sub ExecuteTankBuffs(string buffArray)
	/if (${DebugMode}) /echo ExecuteTankBuffs from array ${buffArray}
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/if (${Target.ID} != ${TankId}) /return FALSE
	/declare i int local
	/declare j int local
	/if (${DebugMode}) /echo looping from buff 1 to ${${buffArray}.Size}
	/for i 1 to ${${buffArray}.Size}
		/if (!${Bool[${${buffArray}[${i}]}]}) {
			/varset ShouldCheckTankBuffs FALSE
			/return FALSE
		}
		/if (${DebugMode}) /echo ExecuteTankBuffs item ${i} on ${Spawn[id ${TankId}]}
		/call RKBuff "${${buffArray}[${i}]}" ${TankId}
		/if (${Me.SpellReady[${${buffArray}[${i}]}]}) /return TRUE
	/next i
	/varset ShouldCheckTankBuffs FALSE
/return FALSE

Sub ExecuteGroupBuffs(string buffArray)
	/if (${DebugMode}) /echo ExecuteGroupBuffs from array ${buffArray}
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/declare i int local
	/declare j int local
	/if (${DebugMode}) /echo looping from buff 1 to ${${buffArray}.Size}
	/for i 1 to ${${buffArray}.Size}
		/if (!${Bool[${${buffArray}[${i}]}]}) /return FALSE

		/if (${DebugMode}) {
			/echo looping from group member 1 to ${${buffArray}.Size}
			/echo Looking at ${Spell[${${buffArray}[${i}]}]} - TargetType: ${Spell[${${buffArray}[${i}]}].TargetType}
		}
		
		/if (${Spell[${${buffArray}[${i}]}].TargetType.Equal[Group v1]} || ${Spell[${${buffArray}[${i}]}].TargetType.Equal[Group v2]}) {
			/if (${Me.Buff[${${buffArray}[${i}]}].ID}) /next i
			/if (${DebugMode}) /echo Casting single target group ability "${${buffArray}[${i}]}"
			/call RKCast "${${buffArray}[${i}]}" ${CurrentTargetId}
			/if (${Macro.Return}) /return FALSE
		} else {
			/for j 0 to ${Group.Members}
				/if (${DebugMode}) /echo ExecuteGroupBuffs item ${i} group member ${j}
				/call RKBuff "${${buffArray}[${i}]}" ${Group.Member[${j}].ID}
				/if (${Macro.Return}) /return TRUE
			/next j		
		}
	/next i
/return FALSE

Sub RKBuffWithUniqueName(string spellName, string buffName, int targetId)
	/if (${DebugMode}) /echo RKBuffWithUniqueName ${spellName} ${buffName} ${targetId}
	/if (!${Bool[${targetId}]}) /declare targetId int inner ${Me.ID}
	/if (${targetId} == ${Me.ID}) {
		/if (${Bool[${Me.Buff[${buffName}]}]} || ${Bool[${Me.Song[${buffName}]}]} || ${Bool[${Me.Aura[${buffName}]}]}) {
			/return FALSE
		}
	}
	
	/if (${Bool[${Target.Buff[${buffName}]}]}) /return FALSE
	
	/if (${targetId} == ${Me.ID}) {
		/call WillSelfBuffStack "${spellName}"
	} else {
		/call WillBuffStack "${spellName}" ${targetId}
	}
	/if (!${Macro.Return}) /return FALSE
	
	/if (!${buffName.Equal[${spellName}]}) {
		/if (${targetId} == ${Me.ID}) {
			/call WillSelfBuffStack "${buffName}"
		} else {
			/call WillBuffStack "${buffName}" ${targetId}
		}
		/if (!${Macro.Return}) /return FALSE
	}
	
	/if (${Spell[${spellName}].TargetType.Equal[Group v1]} || ${Spell[${spellName}].TargetType.Equal[Group v2]}) {
		/call RKMemCast "${spellName}" ${Target.ID}
	} else {
		/call RKMemCast "${spellName}" ${targetId}
	}
/return ${Macro.Return}

Sub RKBuff(string spellName, int targetId)
	/if (${DebugMode}) /echo RKBuff ${spellName} ${targetId}

	/if (${targetId} == ${Me.ID}) {
		/if (${Me.Buff[${spellName}].ID} && ${Me.Buff[${spellName}].Duration.TotalSeconds} > 5) {
			/if (${DebugMode}) /echo already have buff ${spellName}
			/return FALSE
		}

		/if (${Me.Song[${spellName}].ID} && ${Me.Song[${spellName}].Duration} > 10000) {
			/if (${DebugMode}) /echo already have song ${spellName}
			/return FALSE
		}
		
		/if (${Bool[${Me.Aura[${spellName}]}]}) {
			/if (${DebugMode}) /echo already have aura ${spellName}
			/return FALSE
		}
		
		/call WillSelfBuffStack "${spellName}"
		/if (!${Macro.Return}) /return FALSE
	}
	
	/if (${Spell[${${buffArray}[${i}]}].TargetType.Equal[Group v1]} || ${Spell[${${buffArray}[${i}]}].TargetType.Equal[Group v2]}) {
		/call RKCast "${Spell[${${buffArray}[${i}]}]}" ${Target.ID}
		/return TRUE
	}
	
	/declare previousTargetId int local ${Target.ID}
	/call TargetSync ${targetId}
	/if (!${Bool[${Target.Buff}]}) /delay 1s
	/if (!${Macro.Return}) {
		/if (${DebugMode}) /echo couldn't sync target ${targetId} for buff ${spellName}
		/call TargetSync ${previousTargetId}
		/return FALSE
	}
	
	/if (${Target.Buff[${spellName}].ID} && ${Target.Buff[${spellName}].Duration.TotalSeconds} > 5) {
		/if (${DebugMode}) /echo already have ${spellName}
		/return FALSE
	}

	/if (${Bool[${Target.Buff}]}) {
		/call WillBuffStack "${spellName}" ${targetId}
		/if (!${Macro.Return}) {
			/if (${DebugMode}) /echo ${spellName} won't stack on ${targetId}
			/return FALSE
		}
		
		/call RKMemCast "${spellName}" ${targetId}
		/if (${Macro.Return}) {
			/if (${DebugMode}) /echo memcast ${spellName}
			/delay ${Spells[${spellName}].MyCastTime.Int}s
			/return TRUE
		}
		
		/if (!${Me.SpellReady[${spellName}]}) {
			/if (${DebugMode}) /echo awaiting spell: ${spellName}
			/return FALSE
		}
	}
	/call TargetSync ${previousTargetId}
/return FALSE

Sub RKDebuffCast(string spellName, string debuffName, int targetId)
	/if (${DebugMode}) /echo RKDebuffCast ${spellName} ${debuffName} ${targetId}
	/declare previousTargetId int local ${Target.ID}
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/if (${targetId} == 0) {
		/echo RKDebuffCast ${spellName} - ${debuffName} - targetId was 0
		/return FALSE
	}

	/call TargetSync ${targetId}
	/delay 5 ${Bool[${Target.Buff}]}
	/if (!${Macro.Return}) {
		/if (${DebugMode}) /echo couldn't sync target ${targetId} for debuff ${spellName}
		/call TargetSync ${previousTargetId}
		/return FALSE
	}
	
	/if (${DebugMode}) /echo ${debuffName}
	/if (${Target.Buff[${debuffName}].ID} && ${Target.Buff[${debuffName}].Duration.TotalSeconds} > 2) {
		/if (${DebugMode}) /echo target already has ${debuffName}
		/return FALSE
	}
	
	/call RKMemCast "${spellName}" ${targetId}
	/declare castResult bool local ${Macro.Return}
	/if (${DebugMode}) /echo RKCast "${spellName}" ${targetId} - result: ${castResult}
	/call TargetSync ${previousTargetId}
/return ${castResult}

Sub RKMemCast(string spellName, int targetId)
	/if (${Me.Casting.ID} && !${Me.Class.Name.Equal[Bard]}) /return FALSE
	/call IsSpellMemorized "${spellName}"
	/if (${Macro.Return}) {
		/if (!${Me.SpellReady[${spellName}]}) {
			/if (${DebugMode}) /echo RKMemCast - ${spellName} not ready
			/return FALSE
		}
	} else {
		/call MemorizeSpell "${spellName}" ${SpellMemSlot}
		/delay 2s ${Bool[${Me.Gem[${spellName}]}]}
		/if (${DebugMode}) /echo RKMemCast - ${spellName} not memorized
	}
	
	/call RKCast "${spellName}" ${targetId}
/return FALSE

Sub RKCast(string spellName, int targetId)
	/if (${DebugMode}) /echo RKCast ${spellName} ${targetId} ${Spawn[id ${targetId}]}
	/if (!${Me.Class.Name.Equal[Bard]} && ${Me.Moving}) /return FALSE
	
	|/if (${Spell[${spellName}].TargetType.Equal[Detrimental]} && ${Spawn[id ${targetId}].Type.Equal[PC]}) {
	|	/i say: "not casting ${Spell[${spellName}].Name} on ${Spawn[id ${targetId}].CleanName}}"
	|	/return FALSE
	|}
	
	/if (${Spell[${spellName}].Mana} > ${Me.CurrentMana}) /return FALSE
		
	/if (!${Spell[${spellName}].ID}) {
		/docommand /${ChatCommand} "hrm... trying to do something I shouldn't - ${spellName}"
		/return FALSE
	}
	
	/if (${Me.GemTimer[${spellName}]} > 0 && ${Me.GemTimer[${spellName}]} < 50) {
		/delay 6 ${Me.GemTimer[${Me.Gem[${spellName}]}]} == 0
	}
	
	/if (${DebugMode}) /echo casting ${spellName}
	/if (!${Me.SpellReady[${spellName}]}) /return FALSE
	/if (${Me.GemTimer[${Me.Gem[${spellName}]}]} > 0) /return FALSE

	/declare previousTargetId int local ${Target.ID}
	/if (${previousTargetId} != ${targetId}) {
		/call TargetSync ${targetId}
		/if (!${Macro.Return}) /return FALSE
		/delay 8
	}
	
	/declare twisting bool local (${Twist} && ${Me.Class.Name.Equal[Bard]})

	/if (${twisting}) {
		/call TwistCast "${spellName}" ${targetId}
		/if (${Macro.Return}) /return TRUE
	} else {
		/if (${DebugMode}) /echo casting ${spellName} in slot ${Me.Gem[${spellName}]}

		/if (${Me.GemTimer[${Me.Gem[${spellName}]}]} > 0 && ${Me.GemTimer[${Me.Gem[${spellName}]}]} < 200) {
			/delay 250 ${Bool[${Me.GemTimer[${Me.Gem[${spellName}]}]} == 0]}
		}
		
		/cast ${Me.Gem[${spellName}]}
	}
	
	/if (${Cast.Result.Equal[CAST_SUCCESS]}) /delay 2
	/if (${DebugMode}) /echo Cast of ${spellName} result was ${Cast.Result}
/return ${Cast.Result.Equal[CAST_SUCCESS]}

Sub TwistCast(string spellName, int targetId)
	/if (${Me.Gem[${spellName}]} < 10) {
		/if (${DebugMode}) /echo trying to twist once for ${spellName} in gemslot ${Me.Gem[${spellName}]}		
		/twist once ${Me.Gem[${spellName}]}
		/delay 4s
		/if (${Me.Class.Name.Equal[Bard]}) {
			/if (${DebugMode}) /echo stopping cast for twist 1
			/stopcast
			/delay 5
		}
	} else {
		/twist off
		/delay 1s
		/cast "${spellName}"
		/delay 5
		/delay 4s !${Me.Casting.ID}
		/if (${DebugMode}) /echo stop cast of ${spellName}
		/if (${Me.Class.Name.Equal[Bard]}) {
			/echo stopping cast for twist 2
			/stopcast
			/delay 5
			/twist
		}
	}
/return ${Cast.Result.Equal[CAST_SUCCESS]}

Sub CheckMedding
	/if (${DebugMode}) /echo CheckMedding
	
	|If we're not in active combat mode, we short circuit.
	/if (${BOTMode} < 3) /return FALSE
	/if (${Me.PctMana} > ${LowManaLevel}) /return FALSE

	/if (!${Target.ID} && ${BOTMode} <= 3) {
			/varset PreviousBOTMode ${BOTMode}
			/varset BOTMode 0
			|Medding
		}
	}


	/if (${BOTMode} == 5) { 
		/if (!${Bool[${Me.XTarget[1].ID}]}) {
			/if (!${Me.Mount} && !${Me.Sitting}) /sit on
			| After we're done medding, we return the state we were in before.
			/if (${Me.PctMana} == 100) /varset BOTMode ${PreviousBOTMode} 
			/if (!${Bool[${BOTMode}]}) /varset BOTMode 3
			/return TRUE
		}
	} 
/return FALSE

Sub IsSpellMemorized(string spellName)
	/declare i int local
	/for i 1 to 12
		/if (${Me.Gem[${i}].ID} && ${Me.Gem[${i}].Name.Equal[${spellName}]}) /return TRUE
	/next i
/return FALSE

Sub MemorizeSpell(string spellName, int gemSlot)
	/if (${DebugMode}) /echo MemorizeSpell ${spellName} in slot ${gemSlot}
	/declare i int local
	/for i 1 to 12
		/if (${Me.Gem[${i}].ID} && ${Me.Gem[${i}].Name.Equal[${spellName}]}) /return TRUE
	/next i
	/memorize "${spellName}" ${gemSlot}
	/delay 2s ${Me.Gem[${i}].Name.Equal[${spellName}]}
	:spellBookCloser
	/if (${Window[SpellBookWnd]}) {
		/keypress esc
		/delay 1
		/goto :spellBookCloser
	}
	/if (!${Me.Gem[${gemSlot}].Name.Equal[${spellName}]}) /return FALSE
	/if (${Spell[${spellName}].RecastTime} < 10) /delay ${Spell[${spellName}].RecastTime} ${Me.SpellReady[${spellName}]}
/return ${Me.SpellReady[${spellName}]}
